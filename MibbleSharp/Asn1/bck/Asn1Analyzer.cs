// <copyright file="Asn1Analyzer.cs" company="Gibb Co">
// <para>This work is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation; either version 2 of the License,
// or (at your option) any later version.
// </para>
// <para>This work is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.</para>
// 
// <para>You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
// USA</para>
// Copyright (c) 2004-2009 Per Cederberg. All rights reserved.
// </copyright>
namespace MibbleSharp.Asn1
{
    using PerCederberg.Grammatica.Runtime;

    /// <summary>
    /// A class providing callback methods for the parser.
    /// </summary>
    internal abstract class Asn1Analyzer : Analyzer
    {
        /// <summary>Called when entering a parse tree node.</summary>
        /// <param name='node'>the node being entered</param>
        /// <exception cref='ParseException'>if the node analysis
        /// discovered errors</exception>
        public override void Enter(Node node)
        {
            switch (node.Id)
            {
                case (int)Asn1Constants.DOT:
                    this.EnterDot((Token)node);
                    break;
                case (int)Asn1Constants.DOUBLE_DOT:
                    this.EnterDoubleDot((Token)node);
                    break;
                case (int)Asn1Constants.TRIPLE_DOT:
                    this.EnterTripleDot((Token)node);
                    break;
                case (int)Asn1Constants.COMMA:
                    this.EnterComma((Token)node);
                    break;
                case (int)Asn1Constants.SEMI_COLON:
                    this.EnterSemiColon((Token)node);
                    break;
                case (int)Asn1Constants.LEFT_PAREN:
                    this.EnterLeftParen((Token)node);
                    break;
                case (int)Asn1Constants.RIGHT_PAREN:
                    this.EnterRightParen((Token)node);
                    break;
                case (int)Asn1Constants.LEFT_BRACE:
                    this.EnterLeftBrace((Token)node);
                    break;
                case (int)Asn1Constants.RIGHT_BRACE:
                    this.EnterRightBrace((Token)node);
                    break;
                case (int)Asn1Constants.LEFT_BRACKET:
                    this.EnterLeftBracket((Token)node);
                    break;
                case (int)Asn1Constants.RIGHT_BRACKET:
                    this.EnterRightBracket((Token)node);
                    break;
                case (int)Asn1Constants.MINUS:
                    this.EnterMinus((Token)node);
                    break;
                case (int)Asn1Constants.LESS_THAN:
                    this.EnterLessThan((Token)node);
                    break;
                case (int)Asn1Constants.VERTICAL_BAR:
                    this.EnterVerticalBar((Token)node);
                    break;
                case (int)Asn1Constants.DEFINITION:
                    this.EnterDefinition((Token)node);
                    break;
                case (int)Asn1Constants.DEFINITIONS:
                    this.EnterDefinitions((Token)node);
                    break;
                case (int)Asn1Constants.EXPLICIT:
                    this.EnterExplicit((Token)node);
                    break;
                case (int)Asn1Constants.IMPLICIT:
                    this.EnterImplicit((Token)node);
                    break;
                case (int)Asn1Constants.TAGS:
                    this.EnterTags((Token)node);
                    break;
                case (int)Asn1Constants.BEGIN:
                    this.EnterBegin((Token)node);
                    break;
                case (int)Asn1Constants.END:
                    this.EnterEnd((Token)node);
                    break;
                case (int)Asn1Constants.EXPORTS:
                    this.EnterExports((Token)node);
                    break;
                case (int)Asn1Constants.IMPORTS:
                    this.EnterImports((Token)node);
                    break;
                case (int)Asn1Constants.FROM:
                    this.EnterFrom((Token)node);
                    break;
                case (int)Asn1Constants.MACRO:
                    this.EnterMacro((Token)node);
                    break;
                case (int)Asn1Constants.INTEGER:
                    this.EnterInteger((Token)node);
                    break;
                case (int)Asn1Constants.REAL:
                    this.EnterReal((Token)node);
                    break;
                case (int)Asn1Constants.BOOLEAN:
                    this.EnterBoolean((Token)node);
                    break;
                case (int)Asn1Constants.NULL:
                    this.EnterNull((Token)node);
                    break;
                case (int)Asn1Constants.BIT:
                    this.EnterBit((Token)node);
                    break;
                case (int)Asn1Constants.OCTET:
                    this.EnterOctet((Token)node);
                    break;
                case (int)Asn1Constants.STRING:
                    this.EnterString((Token)node);
                    break;
                case (int)Asn1Constants.ENUMERATED:
                    this.EnterEnumerated((Token)node);
                    break;
                case (int)Asn1Constants.SEQUENCE:
                    this.EnterSequence((Token)node);
                    break;
                case (int)Asn1Constants.SET:
                    this.EnterSet((Token)node);
                    break;
                case (int)Asn1Constants.OF:
                    this.EnterOf((Token)node);
                    break;
                case (int)Asn1Constants.CHOICE:
                    this.EnterChoice((Token)node);
                    break;
                case (int)Asn1Constants.UNIVERSAL:
                    this.EnterUniversal((Token)node);
                    break;
                case (int)Asn1Constants.APPLICATION:
                    this.EnterApplication((Token)node);
                    break;
                case (int)Asn1Constants.PRIVATE:
                    this.EnterPrivate((Token)node);
                    break;
                case (int)Asn1Constants.ANY:
                    this.EnterAny((Token)node);
                    break;
                case (int)Asn1Constants.DEFINED:
                    this.EnterDefined((Token)node);
                    break;
                case (int)Asn1Constants.BY:
                    this.EnterBy((Token)node);
                    break;
                case (int)Asn1Constants.OBJECT:
                    this.EnterObject((Token)node);
                    break;
                case (int)Asn1Constants.IDENTIFIER:
                    this.EnterIdentifier((Token)node);
                    break;
                case (int)Asn1Constants.INCLUDES:
                    this.EnterIncludes((Token)node);
                    break;
                case (int)Asn1Constants.MIN:
                    this.EnterMin((Token)node);
                    break;
                case (int)Asn1Constants.MAX:
                    this.EnterMax((Token)node);
                    break;
                case (int)Asn1Constants.SIZE:
                    this.EnterSize((Token)node);
                    break;
                case (int)Asn1Constants.WITH:
                    this.EnterWith((Token)node);
                    break;
                case (int)Asn1Constants.COMPONENT:
                    this.EnterComponent((Token)node);
                    break;
                case (int)Asn1Constants.COMPONENTS:
                    this.EnterComponents((Token)node);
                    break;
                case (int)Asn1Constants.PRESENT:
                    this.EnterPresent((Token)node);
                    break;
                case (int)Asn1Constants.ABSENT:
                    this.EnterAbsent((Token)node);
                    break;
                case (int)Asn1Constants.OPTIONAL:
                    this.EnterOptional((Token)node);
                    break;
                case (int)Asn1Constants.DEFAULT:
                    this.EnterDefault((Token)node);
                    break;
                case (int)Asn1Constants.TRUE:
                    this.EnterTrue((Token)node);
                    break;
                case (int)Asn1Constants.FALSE:
                    this.EnterFalse((Token)node);
                    break;
                case (int)Asn1Constants.PLUS_INFINITY:
                    this.EnterPlusInfinity((Token)node);
                    break;
                case (int)Asn1Constants.MINUS_INFINITY:
                    this.EnterMinusInfinity((Token)node);
                    break;
                case (int)Asn1Constants.MODULE_IDENTITY:
                    this.EnterModuleIdentity((Token)node);
                    break;
                case (int)Asn1Constants.OBJECT_IDENTITY:
                    this.EnterObjectIdentity((Token)node);
                    break;
                case (int)Asn1Constants.OBJECT_TYPE:
                    this.EnterObjectType((Token)node);
                    break;
                case (int)Asn1Constants.NOTIFICATION_TYPE:
                    this.EnterNotificationType((Token)node);
                    break;
                case (int)Asn1Constants.TRAP_TYPE:
                    this.EnterTrapType((Token)node);
                    break;
                case (int)Asn1Constants.TEXTUAL_CONVENTION:
                    this.EnterTextualConvention((Token)node);
                    break;
                case (int)Asn1Constants.OBJECT_GROUP:
                    this.EnterObjectGroup((Token)node);
                    break;
                case (int)Asn1Constants.NOTIFICATION_GROUP:
                    this.EnterNotificationGroup((Token)node);
                    break;
                case (int)Asn1Constants.MODULE_COMPLIANCE:
                    this.EnterModuleCompliance((Token)node);
                    break;
                case (int)Asn1Constants.AGENT_CAPABILITIES:
                    this.EnterAgentCapabilities((Token)node);
                    break;
                case (int)Asn1Constants.LAST_UPDATED:
                    this.EnterLastUpdated((Token)node);
                    break;
                case (int)Asn1Constants.ORGANIZATION:
                    this.EnterOrganization((Token)node);
                    break;
                case (int)Asn1Constants.CONTACT_INFO:
                    this.EnterContactInfo((Token)node);
                    break;
                case (int)Asn1Constants.DESCRIPTION:
                    this.EnterDescription((Token)node);
                    break;
                case (int)Asn1Constants.REVISION:
                    this.EnterRevision((Token)node);
                    break;
                case (int)Asn1Constants.STATUS:
                    this.EnterStatus((Token)node);
                    break;
                case (int)Asn1Constants.REFERENCE:
                    this.EnterReference((Token)node);
                    break;
                case (int)Asn1Constants.SYNTAX:
                    this.EnterSyntax((Token)node);
                    break;
                case (int)Asn1Constants.BITS:
                    this.EnterBits((Token)node);
                    break;
                case (int)Asn1Constants.UNITS:
                    this.EnterUnits((Token)node);
                    break;
                case (int)Asn1Constants.ACCESS:
                    this.EnterAccess((Token)node);
                    break;
                case (int)Asn1Constants.MAX_ACCESS:
                    this.EnterMaxAccess((Token)node);
                    break;
                case (int)Asn1Constants.MIN_ACCESS:
                    this.EnterMinAccess((Token)node);
                    break;
                case (int)Asn1Constants.INDEX:
                    this.EnterIndex((Token)node);
                    break;
                case (int)Asn1Constants.AUGMENTS:
                    this.EnterAugments((Token)node);
                    break;
                case (int)Asn1Constants.IMPLIED:
                    this.EnterImplied((Token)node);
                    break;
                case (int)Asn1Constants.DEFVAL:
                    this.EnterDefval((Token)node);
                    break;
                case (int)Asn1Constants.OBJECTS:
                    this.EnterObjects((Token)node);
                    break;
                case (int)Asn1Constants.ENTERPRISE:
                    this.EnterEnterprise((Token)node);
                    break;
                case (int)Asn1Constants.VARIABLES:
                    this.EnterVariables((Token)node);
                    break;
                case (int)Asn1Constants.DISPLAY_HINT:
                    this.EnterDisplayHint((Token)node);
                    break;
                case (int)Asn1Constants.NOTIFICATIONS:
                    this.EnterNotifications((Token)node);
                    break;
                case (int)Asn1Constants.MODULE:
                    this.EnterModule((Token)node);
                    break;
                case (int)Asn1Constants.MANDATORY_GROUPS:
                    this.EnterMandatoryGroups((Token)node);
                    break;
                case (int)Asn1Constants.GROUP:
                    this.EnterGroup((Token)node);
                    break;
                case (int)Asn1Constants.WRITE_SYNTAX:
                    this.EnterWriteSyntax((Token)node);
                    break;
                case (int)Asn1Constants.PRODUCT_RELEASE:
                    this.EnterProductRelease((Token)node);
                    break;
                case (int)Asn1Constants.SUPPORTS:
                    this.EnterSupports((Token)node);
                    break;
                case (int)Asn1Constants.VARIATION:
                    this.EnterVariation((Token)node);
                    break;
                case (int)Asn1Constants.CREATION_REQUIRES:
                    this.EnterCreationRequires((Token)node);
                    break;
                case (int)Asn1Constants.BINARY_STRING:
                    this.EnterBinaryString((Token)node);
                    break;
                case (int)Asn1Constants.HEXADECIMAL_STRING:
                    this.EnterHexadecimalString((Token)node);
                    break;
                case (int)Asn1Constants.QUOTED_STRING:
                    this.EnterQuotedString((Token)node);
                    break;
                case (int)Asn1Constants.IDENTIFIER_STRING:
                    this.EnterIdentifierString((Token)node);
                    break;
                case (int)Asn1Constants.NUMBER_STRING:
                    this.EnterNumberString((Token)node);
                    break;
                case (int)Asn1Constants.START:
                    this.EnterStart((Production)node);
                    break;
                case (int)Asn1Constants.MODULE_DEFINITION:
                    this.EnterModuleDefinition((Production)node);
                    break;
                case (int)Asn1Constants.MODULE_IDENTIFIER:
                    this.EnterModuleIdentifier((Production)node);
                    break;
                case (int)Asn1Constants.MODULE_REFERENCE:
                    this.EnterModuleReference((Production)node);
                    break;
                case (int)Asn1Constants.TAG_DEFAULT:
                    this.EnterTagDefault((Production)node);
                    break;
                case (int)Asn1Constants.MODULE_BODY:
                    this.EnterModuleBody((Production)node);
                    break;
                case (int)Asn1Constants.EXPORT_LIST:
                    this.EnterExportList((Production)node);
                    break;
                case (int)Asn1Constants.IMPORT_LIST:
                    this.EnterImportList((Production)node);
                    break;
                case (int)Asn1Constants.SYMBOLS_FROM_MODULE:
                    this.EnterSymbolsFromModule((Production)node);
                    break;
                case (int)Asn1Constants.SYMBOL_LIST:
                    this.EnterSymbolList((Production)node);
                    break;
                case (int)Asn1Constants.SYMBOL:
                    this.EnterSymbol((Production)node);
                    break;
                case (int)Asn1Constants.ASSIGNMENT_LIST:
                    this.EnterAssignmentList((Production)node);
                    break;
                case (int)Asn1Constants.ASSIGNMENT:
                    this.EnterAssignment((Production)node);
                    break;
                case (int)Asn1Constants.MACRO_DEFINITION:
                    this.EnterMacroDefinition((Production)node);
                    break;
                case (int)Asn1Constants.MACRO_REFERENCE:
                    this.EnterMacroReference((Production)node);
                    break;
                case (int)Asn1Constants.MACRO_BODY:
                    this.EnterMacroBody((Production)node);
                    break;
                case (int)Asn1Constants.MACRO_BODY_ELEMENT:
                    this.EnterMacroBodyElement((Production)node);
                    break;
                case (int)Asn1Constants.TYPE_ASSIGNMENT:
                    this.EnterTypeAssignment((Production)node);
                    break;
                case (int)Asn1Constants.TYPE:
                    this.EnterType((Production)node);
                    break;
                case (int)Asn1Constants.DEFINED_TYPE:
                    this.EnterDefinedType((Production)node);
                    break;
                case (int)Asn1Constants.BUILTIN_TYPE:
                    this.EnterBuiltinType((Production)node);
                    break;
                case (int)Asn1Constants.NULL_TYPE:
                    this.EnterNullType((Production)node);
                    break;
                case (int)Asn1Constants.BOOLEAN_TYPE:
                    this.EnterBooleanType((Production)node);
                    break;
                case (int)Asn1Constants.REAL_TYPE:
                    this.EnterRealType((Production)node);
                    break;
                case (int)Asn1Constants.INTEGER_TYPE:
                    this.EnterIntegerType((Production)node);
                    break;
                case (int)Asn1Constants.OBJECT_IDENTIFIER_TYPE:
                    this.EnterObjectIdentifierType((Production)node);
                    break;
                case (int)Asn1Constants.STRING_TYPE:
                    this.EnterStringType((Production)node);
                    break;
                case (int)Asn1Constants.BIT_STRING_TYPE:
                    this.EnterBitStringType((Production)node);
                    break;
                case (int)Asn1Constants.BITS_TYPE:
                    this.EnterBitsType((Production)node);
                    break;
                case (int)Asn1Constants.SEQUENCE_TYPE:
                    this.EnterSequenceType((Production)node);
                    break;
                case (int)Asn1Constants.SEQUENCE_OF_TYPE:
                    this.EnterSequenceOfType((Production)node);
                    break;
                case (int)Asn1Constants.SET_TYPE:
                    this.EnterSetType((Production)node);
                    break;
                case (int)Asn1Constants.SET_OF_TYPE:
                    this.EnterSetOfType((Production)node);
                    break;
                case (int)Asn1Constants.CHOICE_TYPE:
                    this.EnterChoiceType((Production)node);
                    break;
                case (int)Asn1Constants.ENUMERATED_TYPE:
                    this.EnterEnumeratedType((Production)node);
                    break;
                case (int)Asn1Constants.SELECTION_TYPE:
                    this.EnterSelectionType((Production)node);
                    break;
                case (int)Asn1Constants.TAGGED_TYPE:
                    this.EnterTaggedType((Production)node);
                    break;
                case (int)Asn1Constants.TAG:
                    this.EnterTag((Production)node);
                    break;
                case (int)Asn1Constants.CLASS:
                    this.EnterClass((Production)node);
                    break;
                case (int)Asn1Constants.EXPLICIT_OR_IMPLICIT_TAG:
                    this.EnterExplicitOrImplicitTag((Production)node);
                    break;
                case (int)Asn1Constants.ANY_TYPE:
                    this.EnterAnyType((Production)node);
                    break;
                case (int)Asn1Constants.ELEMENT_TYPE_LIST:
                    this.EnterElementTypeList((Production)node);
                    break;
                case (int)Asn1Constants.ELEMENT_TYPE:
                    this.EnterElementType((Production)node);
                    break;
                case (int)Asn1Constants.OPTIONAL_OR_DEFAULT_ELEMENT:
                    this.EnterOptionalOrDefaultElement((Production)node);
                    break;
                case (int)Asn1Constants.VALUE_OR_CONSTRAINT_LIST:
                    this.EnterValueOrConstraintList((Production)node);
                    break;
                case (int)Asn1Constants.NAMED_NUMBER_LIST:
                    this.EnterNamedNumberList((Production)node);
                    break;
                case (int)Asn1Constants.NAMED_NUMBER:
                    this.EnterNamedNumber((Production)node);
                    break;
                case (int)Asn1Constants.NUMBER:
                    this.EnterNumber((Production)node);
                    break;
                case (int)Asn1Constants.CONSTRAINT_LIST:
                    this.EnterConstraintList((Production)node);
                    break;
                case (int)Asn1Constants.CONSTRAINT:
                    this.EnterConstraint((Production)node);
                    break;
                case (int)Asn1Constants.VALUE_CONSTRAINT_LIST:
                    this.EnterValueConstraintList((Production)node);
                    break;
                case (int)Asn1Constants.VALUE_CONSTRAINT:
                    this.EnterValueConstraint((Production)node);
                    break;
                case (int)Asn1Constants.VALUE_RANGE:
                    this.EnterValueRange((Production)node);
                    break;
                case (int)Asn1Constants.LOWER_END_POINT:
                    this.EnterLowerEndPoint((Production)node);
                    break;
                case (int)Asn1Constants.UPPER_END_POINT:
                    this.EnterUpperEndPoint((Production)node);
                    break;
                case (int)Asn1Constants.SIZE_CONSTRAINT:
                    this.EnterSizeConstraint((Production)node);
                    break;
                case (int)Asn1Constants.ALPHABET_CONSTRAINT:
                    this.EnterAlphabetConstraint((Production)node);
                    break;
                case (int)Asn1Constants.CONTAINED_TYPE_CONSTRAINT:
                    this.EnterContainedTypeConstraint((Production)node);
                    break;
                case (int)Asn1Constants.INNER_TYPE_CONSTRAINT:
                    this.EnterInnerTypeConstraint((Production)node);
                    break;
                case (int)Asn1Constants.COMPONENTS_LIST:
                    this.EnterComponentsList((Production)node);
                    break;
                case (int)Asn1Constants.COMPONENTS_LIST_TAIL:
                    this.EnterComponentsListTail((Production)node);
                    break;
                case (int)Asn1Constants.COMPONENT_CONSTRAINT:
                    this.EnterComponentConstraint((Production)node);
                    break;
                case (int)Asn1Constants.COMPONENT_VALUE_PRESENCE:
                    this.EnterComponentValuePresence((Production)node);
                    break;
                case (int)Asn1Constants.COMPONENT_PRESENCE:
                    this.EnterComponentPresence((Production)node);
                    break;
                case (int)Asn1Constants.VALUE_ASSIGNMENT:
                    this.EnterValueAssignment((Production)node);
                    break;
                case (int)Asn1Constants.VALUE:
                    this.EnterValue((Production)node);
                    break;
                case (int)Asn1Constants.DEFINED_VALUE:
                    this.EnterDefinedValue((Production)node);
                    break;
                case (int)Asn1Constants.BUILTIN_VALUE:
                    this.EnterBuiltinValue((Production)node);
                    break;
                case (int)Asn1Constants.NULL_VALUE:
                    this.EnterNullValue((Production)node);
                    break;
                case (int)Asn1Constants.BOOLEAN_VALUE:
                    this.EnterBooleanValue((Production)node);
                    break;
                case (int)Asn1Constants.SPECIAL_REAL_VALUE:
                    this.EnterSpecialRealValue((Production)node);
                    break;
                case (int)Asn1Constants.NUMBER_VALUE:
                    this.EnterNumberValue((Production)node);
                    break;
                case (int)Asn1Constants.BINARY_VALUE:
                    this.EnterBinaryValue((Production)node);
                    break;
                case (int)Asn1Constants.HEXADECIMAL_VALUE:
                    this.EnterHexadecimalValue((Production)node);
                    break;
                case (int)Asn1Constants.STRING_VALUE:
                    this.EnterStringValue((Production)node);
                    break;
                case (int)Asn1Constants.BIT_OR_OBJECT_IDENTIFIER_VALUE:
                    this.EnterBitOrObjectIdentifierValue((Production)node);
                    break;
                case (int)Asn1Constants.BIT_VALUE:
                    this.EnterBitValue((Production)node);
                    break;
                case (int)Asn1Constants.OBJECT_IDENTIFIER_VALUE:
                    this.EnterObjectIdentifierValue((Production)node);
                    break;
                case (int)Asn1Constants.NAME_VALUE_LIST:
                    this.EnterNameValueList((Production)node);
                    break;
                case (int)Asn1Constants.NAME_VALUE_COMPONENT:
                    this.EnterNameValueComponent((Production)node);
                    break;
                case (int)Asn1Constants.NAME_OR_NUMBER:
                    this.EnterNameOrNumber((Production)node);
                    break;
                case (int)Asn1Constants.NAME_AND_NUMBER:
                    this.EnterNameAndNumber((Production)node);
                    break;
                case (int)Asn1Constants.DEFINED_MACRO_TYPE:
                    this.EnterDefinedMacroType((Production)node);
                    break;
                case (int)Asn1Constants.DEFINED_MACRO_NAME:
                    this.EnterDefinedMacroName((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_MODULE_IDENTITY_MACRO_TYPE:
                    this.EnterSnmpModuleIdentityMacroType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_OBJECT_IDENTITY_MACRO_TYPE:
                    this.EnterSnmpObjectIdentityMacroType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_OBJECT_TYPE_MACRO_TYPE:
                    this.EnterSnmpObjectTypeMacroType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_NOTIFICATION_TYPE_MACRO_TYPE:
                    this.EnterSnmpNotificationTypeMacroType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_TRAP_TYPE_MACRO_TYPE:
                    this.EnterSnmpTrapTypeMacroType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_TEXTUAL_CONVENTION_MACRO_TYPE:
                    this.EnterSnmpTextualConventionMacroType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_OBJECT_GROUP_MACRO_TYPE:
                    this.EnterSnmpObjectGroupMacroType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_NOTIFICATION_GROUP_MACRO_TYPE:
                    this.EnterSnmpNotificationGroupMacroType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_MODULE_COMPLIANCE_MACRO_TYPE:
                    this.EnterSnmpModuleComplianceMacroType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_AGENT_CAPABILITIES_MACRO_TYPE:
                    this.EnterSnmpAgentCapabilitiesMacroType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_UPDATE_PART:
                    this.EnterSnmpUpdatePart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_ORGANIZATION_PART:
                    this.EnterSnmpOrganizationPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_CONTACT_PART:
                    this.EnterSnmpContactPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_DESCR_PART:
                    this.EnterSnmpDescrPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_REVISION_PART:
                    this.EnterSnmpRevisionPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_STATUS_PART:
                    this.EnterSnmpStatusPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_REFER_PART:
                    this.EnterSnmpReferPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_SYNTAX_PART:
                    this.EnterSnmpSyntaxPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_UNITS_PART:
                    this.EnterSnmpUnitsPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_ACCESS_PART:
                    this.EnterSnmpAccessPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_INDEX_PART:
                    this.EnterSnmpIndexPart((Production)node);
                    break;
                case (int)Asn1Constants.INDEX_VALUE_LIST:
                    this.EnterIndexValueList((Production)node);
                    break;
                case (int)Asn1Constants.INDEX_VALUE:
                    this.EnterIndexValue((Production)node);
                    break;
                case (int)Asn1Constants.INDEX_TYPE:
                    this.EnterIndexType((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_DEF_VAL_PART:
                    this.EnterSnmpDefValPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_OBJECTS_PART:
                    this.EnterSnmpObjectsPart((Production)node);
                    break;
                case (int)Asn1Constants.VALUE_LIST:
                    this.EnterValueList((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_ENTERPRISE_PART:
                    this.EnterSnmpEnterprisePart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_VAR_PART:
                    this.EnterSnmpVarPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_DISPLAY_PART:
                    this.EnterSnmpDisplayPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_NOTIFICATIONS_PART:
                    this.EnterSnmpNotificationsPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_MODULE_PART:
                    this.EnterSnmpModulePart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_MODULE_IMPORT:
                    this.EnterSnmpModuleImport((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_MANDATORY_PART:
                    this.EnterSnmpMandatoryPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_COMPLIANCE_PART:
                    this.EnterSnmpCompliancePart((Production)node);
                    break;
                case (int)Asn1Constants.COMPLIANCE_GROUP:
                    this.EnterComplianceGroup((Production)node);
                    break;
                case (int)Asn1Constants.COMPLIANCE_OBJECT:
                    this.EnterComplianceObject((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_WRITE_SYNTAX_PART:
                    this.EnterSnmpWriteSyntaxPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_PRODUCT_RELEASE_PART:
                    this.EnterSnmpProductReleasePart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_MODULE_SUPPORT_PART:
                    this.EnterSnmpModuleSupportPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_VARIATION_PART:
                    this.EnterSnmpVariationPart((Production)node);
                    break;
                case (int)Asn1Constants.SNMP_CREATION_PART:
                    this.EnterSnmpCreationPart((Production)node);
                    break;
            }
        }

        /// <summary>
        /// Called when exiting a parse tree node.
        /// </summary>
        /// <param name='node'>the node being exited</param>
        /// <returns>the node to add to the parse tree, or
        ///          null if no parse tree should be created</returns>
        /// <exception cref='ParseException'>
        /// If the node analysis discovered errors
        /// </exception>
        public override Node Exit(Node node)
        {
            switch (node.Id)
            {
                case (int)Asn1Constants.DOT:
                    return this.ExitDot((Token)node);
                case (int)Asn1Constants.DOUBLE_DOT:
                    return this.ExitDoubleDot((Token)node);
                case (int)Asn1Constants.TRIPLE_DOT:
                    return this.ExitTripleDot((Token)node);
                case (int)Asn1Constants.COMMA:
                    return this.ExitComma((Token)node);
                case (int)Asn1Constants.SEMI_COLON:
                    return this.ExitSemiColon((Token)node);
                case (int)Asn1Constants.LEFT_PAREN:
                    return this.ExitLeftParen((Token)node);
                case (int)Asn1Constants.RIGHT_PAREN:
                    return this.ExitRightParen((Token)node);
                case (int)Asn1Constants.LEFT_BRACE:
                    return this.ExitLeftBrace((Token)node);
                case (int)Asn1Constants.RIGHT_BRACE:
                    return this.ExitRightBrace((Token)node);
                case (int)Asn1Constants.LEFT_BRACKET:
                    return this.ExitLeftBracket((Token)node);
                case (int)Asn1Constants.RIGHT_BRACKET:
                    return this.ExitRightBracket((Token)node);
                case (int)Asn1Constants.MINUS:
                    return this.ExitMinus((Token)node);
                case (int)Asn1Constants.LESS_THAN:
                    return this.ExitLessThan((Token)node);
                case (int)Asn1Constants.VERTICAL_BAR:
                    return this.ExitVerticalBar((Token)node);
                case (int)Asn1Constants.DEFINITION:
                    return this.ExitDefinition((Token)node);
                case (int)Asn1Constants.DEFINITIONS:
                    return this.ExitDefinitions((Token)node);
                case (int)Asn1Constants.EXPLICIT:
                    return this.ExitExplicit((Token)node);
                case (int)Asn1Constants.IMPLICIT:
                    return this.ExitImplicit((Token)node);
                case (int)Asn1Constants.TAGS:
                    return this.ExitTags((Token)node);
                case (int)Asn1Constants.BEGIN:
                    return this.ExitBegin((Token)node);
                case (int)Asn1Constants.END:
                    return this.ExitEnd((Token)node);
                case (int)Asn1Constants.EXPORTS:
                    return this.ExitExports((Token)node);
                case (int)Asn1Constants.IMPORTS:
                    return this.ExitImports((Token)node);
                case (int)Asn1Constants.FROM:
                    return this.ExitFrom((Token)node);
                case (int)Asn1Constants.MACRO:
                    return this.ExitMacro((Token)node);
                case (int)Asn1Constants.INTEGER:
                    return this.ExitInteger((Token)node);
                case (int)Asn1Constants.REAL:
                    return this.ExitReal((Token)node);
                case (int)Asn1Constants.BOOLEAN:
                    return this.ExitBoolean((Token)node);
                case (int)Asn1Constants.NULL:
                    return this.ExitNull((Token)node);
                case (int)Asn1Constants.BIT:
                    return this.ExitBit((Token)node);
                case (int)Asn1Constants.OCTET:
                    return this.ExitOctet((Token)node);
                case (int)Asn1Constants.STRING:
                    return this.ExitString((Token)node);
                case (int)Asn1Constants.ENUMERATED:
                    return this.ExitEnumerated((Token)node);
                case (int)Asn1Constants.SEQUENCE:
                    return this.ExitSequence((Token)node);
                case (int)Asn1Constants.SET:
                    return this.ExitSet((Token)node);
                case (int)Asn1Constants.OF:
                    return this.ExitOf((Token)node);
                case (int)Asn1Constants.CHOICE:
                    return this.ExitChoice((Token)node);
                case (int)Asn1Constants.UNIVERSAL:
                    return this.ExitUniversal((Token)node);
                case (int)Asn1Constants.APPLICATION:
                    return this.ExitApplication((Token)node);
                case (int)Asn1Constants.PRIVATE:
                    return this.ExitPrivate((Token)node);
                case (int)Asn1Constants.ANY:
                    return this.ExitAny((Token)node);
                case (int)Asn1Constants.DEFINED:
                    return this.ExitDefined((Token)node);
                case (int)Asn1Constants.BY:
                    return this.ExitBy((Token)node);
                case (int)Asn1Constants.OBJECT:
                    return this.ExitObject((Token)node);
                case (int)Asn1Constants.IDENTIFIER:
                    return this.ExitIdentifier((Token)node);
                case (int)Asn1Constants.INCLUDES:
                    return this.ExitIncludes((Token)node);
                case (int)Asn1Constants.MIN:
                    return this.ExitMin((Token)node);
                case (int)Asn1Constants.MAX:
                    return this.ExitMax((Token)node);
                case (int)Asn1Constants.SIZE:
                    return this.ExitSize((Token)node);
                case (int)Asn1Constants.WITH:
                    return this.ExitWith((Token)node);
                case (int)Asn1Constants.COMPONENT:
                    return this.ExitComponent((Token)node);
                case (int)Asn1Constants.COMPONENTS:
                    return this.ExitComponents((Token)node);
                case (int)Asn1Constants.PRESENT:
                    return this.ExitPresent((Token)node);
                case (int)Asn1Constants.ABSENT:
                    return this.ExitAbsent((Token)node);
                case (int)Asn1Constants.OPTIONAL:
                    return this.ExitOptional((Token)node);
                case (int)Asn1Constants.DEFAULT:
                    return this.ExitDefault((Token)node);
                case (int)Asn1Constants.TRUE:
                    return this.ExitTrue((Token)node);
                case (int)Asn1Constants.FALSE:
                    return this.ExitFalse((Token)node);
                case (int)Asn1Constants.PLUS_INFINITY:
                    return this.ExitPlusInfinity((Token)node);
                case (int)Asn1Constants.MINUS_INFINITY:
                    return this.ExitMinusInfinity((Token)node);
                case (int)Asn1Constants.MODULE_IDENTITY:
                    return this.ExitModuleIdentity((Token)node);
                case (int)Asn1Constants.OBJECT_IDENTITY:
                    return this.ExitObjectIdentity((Token)node);
                case (int)Asn1Constants.OBJECT_TYPE:
                    return this.ExitObjectType((Token)node);
                case (int)Asn1Constants.NOTIFICATION_TYPE:
                    return this.ExitNotificationType((Token)node);
                case (int)Asn1Constants.TRAP_TYPE:
                    return this.ExitTrapType((Token)node);
                case (int)Asn1Constants.TEXTUAL_CONVENTION:
                    return this.ExitTextualConvention((Token)node);
                case (int)Asn1Constants.OBJECT_GROUP:
                    return this.ExitObjectGroup((Token)node);
                case (int)Asn1Constants.NOTIFICATION_GROUP:
                    return this.ExitNotificationGroup((Token)node);
                case (int)Asn1Constants.MODULE_COMPLIANCE:
                    return this.ExitModuleCompliance((Token)node);
                case (int)Asn1Constants.AGENT_CAPABILITIES:
                    return this.ExitAgentCapabilities((Token)node);
                case (int)Asn1Constants.LAST_UPDATED:
                    return this.ExitLastUpdated((Token)node);
                case (int)Asn1Constants.ORGANIZATION:
                    return this.ExitOrganization((Token)node);
                case (int)Asn1Constants.CONTACT_INFO:
                    return this.ExitContactInfo((Token)node);
                case (int)Asn1Constants.DESCRIPTION:
                    return this.ExitDescription((Token)node);
                case (int)Asn1Constants.REVISION:
                    return this.ExitRevision((Token)node);
                case (int)Asn1Constants.STATUS:
                    return this.ExitStatus((Token)node);
                case (int)Asn1Constants.REFERENCE:
                    return this.ExitReference((Token)node);
                case (int)Asn1Constants.SYNTAX:
                    return this.ExitSyntax((Token)node);
                case (int)Asn1Constants.BITS:
                    return this.ExitBits((Token)node);
                case (int)Asn1Constants.UNITS:
                    return this.ExitUnits((Token)node);
                case (int)Asn1Constants.ACCESS:
                    return this.ExitAccess((Token)node);
                case (int)Asn1Constants.MAX_ACCESS:
                    return this.ExitMaxAccess((Token)node);
                case (int)Asn1Constants.MIN_ACCESS:
                    return this.ExitMinAccess((Token)node);
                case (int)Asn1Constants.INDEX:
                    return this.ExitIndex((Token)node);
                case (int)Asn1Constants.AUGMENTS:
                    return this.ExitAugments((Token)node);
                case (int)Asn1Constants.IMPLIED:
                    return this.ExitImplied((Token)node);
                case (int)Asn1Constants.DEFVAL:
                    return this.ExitDefval((Token)node);
                case (int)Asn1Constants.OBJECTS:
                    return this.ExitObjects((Token)node);
                case (int)Asn1Constants.ENTERPRISE:
                    return this.ExitEnterprise((Token)node);
                case (int)Asn1Constants.VARIABLES:
                    return this.ExitVariables((Token)node);
                case (int)Asn1Constants.DISPLAY_HINT:
                    return this.ExitDisplayHint((Token)node);
                case (int)Asn1Constants.NOTIFICATIONS:
                    return this.ExitNotifications((Token)node);
                case (int)Asn1Constants.MODULE:
                    return this.ExitModule((Token)node);
                case (int)Asn1Constants.MANDATORY_GROUPS:
                    return this.ExitMandatoryGroups((Token)node);
                case (int)Asn1Constants.GROUP:
                    return this.ExitGroup((Token)node);
                case (int)Asn1Constants.WRITE_SYNTAX:
                    return this.ExitWriteSyntax((Token)node);
                case (int)Asn1Constants.PRODUCT_RELEASE:
                    return this.ExitProductRelease((Token)node);
                case (int)Asn1Constants.SUPPORTS:
                    return this.ExitSupports((Token)node);
                case (int)Asn1Constants.VARIATION:
                    return this.ExitVariation((Token)node);
                case (int)Asn1Constants.CREATION_REQUIRES:
                    return this.ExitCreationRequires((Token)node);
                case (int)Asn1Constants.BINARY_STRING:
                    return this.ExitBinaryString((Token)node);
                case (int)Asn1Constants.HEXADECIMAL_STRING:
                    return this.ExitHexadecimalString((Token)node);
                case (int)Asn1Constants.QUOTED_STRING:
                    return this.ExitQuotedString((Token)node);
                case (int)Asn1Constants.IDENTIFIER_STRING:
                    return this.ExitIdentifierString((Token)node);
                case (int)Asn1Constants.NUMBER_STRING:
                    return this.ExitNumberString((Token)node);
                case (int)Asn1Constants.START:
                    return this.ExitStart((Production)node);
                case (int)Asn1Constants.MODULE_DEFINITION:
                    return this.ExitModuleDefinition((Production)node);
                case (int)Asn1Constants.MODULE_IDENTIFIER:
                    return this.ExitModuleIdentifier((Production)node);
                case (int)Asn1Constants.MODULE_REFERENCE:
                    return this.ExitModuleReference((Production)node);
                case (int)Asn1Constants.TAG_DEFAULT:
                    return this.ExitTagDefault((Production)node);
                case (int)Asn1Constants.MODULE_BODY:
                    return this.ExitModuleBody((Production)node);
                case (int)Asn1Constants.EXPORT_LIST:
                    return this.ExitExportList((Production)node);
                case (int)Asn1Constants.IMPORT_LIST:
                    return this.ExitImportList((Production)node);
                case (int)Asn1Constants.SYMBOLS_FROM_MODULE:
                    return this.ExitSymbolsFromModule((Production)node);
                case (int)Asn1Constants.SYMBOL_LIST:
                    return this.ExitSymbolList((Production)node);
                case (int)Asn1Constants.SYMBOL:
                    return this.ExitSymbol((Production)node);
                case (int)Asn1Constants.ASSIGNMENT_LIST:
                    return this.ExitAssignmentList((Production)node);
                case (int)Asn1Constants.ASSIGNMENT:
                    return this.ExitAssignment((Production)node);
                case (int)Asn1Constants.MACRO_DEFINITION:
                    return this.ExitMacroDefinition((Production)node);
                case (int)Asn1Constants.MACRO_REFERENCE:
                    return this.ExitMacroReference((Production)node);
                case (int)Asn1Constants.MACRO_BODY:
                    return this.ExitMacroBody((Production)node);
                case (int)Asn1Constants.MACRO_BODY_ELEMENT:
                    return this.ExitMacroBodyElement((Production)node);
                case (int)Asn1Constants.TYPE_ASSIGNMENT:
                    return this.ExitTypeAssignment((Production)node);
                case (int)Asn1Constants.TYPE:
                    return this.ExitType((Production)node);
                case (int)Asn1Constants.DEFINED_TYPE:
                    return this.ExitDefinedType((Production)node);
                case (int)Asn1Constants.BUILTIN_TYPE:
                    return this.ExitBuiltinType((Production)node);
                case (int)Asn1Constants.NULL_TYPE:
                    return this.ExitNullType((Production)node);
                case (int)Asn1Constants.BOOLEAN_TYPE:
                    return this.ExitBooleanType((Production)node);
                case (int)Asn1Constants.REAL_TYPE:
                    return this.ExitRealType((Production)node);
                case (int)Asn1Constants.INTEGER_TYPE:
                    return this.ExitIntegerType((Production)node);
                case (int)Asn1Constants.OBJECT_IDENTIFIER_TYPE:
                    return this.ExitObjectIdentifierType((Production)node);
                case (int)Asn1Constants.STRING_TYPE:
                    return this.ExitStringType((Production)node);
                case (int)Asn1Constants.BIT_STRING_TYPE:
                    return this.ExitBitStringType((Production)node);
                case (int)Asn1Constants.BITS_TYPE:
                    return this.ExitBitsType((Production)node);
                case (int)Asn1Constants.SEQUENCE_TYPE:
                    return this.ExitSequenceType((Production)node);
                case (int)Asn1Constants.SEQUENCE_OF_TYPE:
                    return this.ExitSequenceOfType((Production)node);
                case (int)Asn1Constants.SET_TYPE:
                    return this.ExitSetType((Production)node);
                case (int)Asn1Constants.SET_OF_TYPE:
                    return this.ExitSetOfType((Production)node);
                case (int)Asn1Constants.CHOICE_TYPE:
                    return this.ExitChoiceType((Production)node);
                case (int)Asn1Constants.ENUMERATED_TYPE:
                    return this.ExitEnumeratedType((Production)node);
                case (int)Asn1Constants.SELECTION_TYPE:
                    return this.ExitSelectionType((Production)node);
                case (int)Asn1Constants.TAGGED_TYPE:
                    return this.ExitTaggedType((Production)node);
                case (int)Asn1Constants.TAG:
                    return this.ExitTag((Production)node);
                case (int)Asn1Constants.CLASS:
                    return this.ExitClass((Production)node);
                case (int)Asn1Constants.EXPLICIT_OR_IMPLICIT_TAG:
                    return this.ExitExplicitOrImplicitTag((Production)node);
                case (int)Asn1Constants.ANY_TYPE:
                    return this.ExitAnyType((Production)node);
                case (int)Asn1Constants.ELEMENT_TYPE_LIST:
                    return this.ExitElementTypeList((Production)node);
                case (int)Asn1Constants.ELEMENT_TYPE:
                    return this.ExitElementType((Production)node);
                case (int)Asn1Constants.OPTIONAL_OR_DEFAULT_ELEMENT:
                    return this.ExitOptionalOrDefaultElement((Production)node);
                case (int)Asn1Constants.VALUE_OR_CONSTRAINT_LIST:
                    return this.ExitValueOrConstraintList((Production)node);
                case (int)Asn1Constants.NAMED_NUMBER_LIST:
                    return this.ExitNamedNumberList((Production)node);
                case (int)Asn1Constants.NAMED_NUMBER:
                    return this.ExitNamedNumber((Production)node);
                case (int)Asn1Constants.NUMBER:
                    return this.ExitNumber((Production)node);
                case (int)Asn1Constants.CONSTRAINT_LIST:
                    return this.ExitConstraintList((Production)node);
                case (int)Asn1Constants.CONSTRAINT:
                    return this.ExitConstraint((Production)node);
                case (int)Asn1Constants.VALUE_CONSTRAINT_LIST:
                    return this.ExitValueConstraintList((Production)node);
                case (int)Asn1Constants.VALUE_CONSTRAINT:
                    return this.ExitValueConstraint((Production)node);
                case (int)Asn1Constants.VALUE_RANGE:
                    return this.ExitValueRange((Production)node);
                case (int)Asn1Constants.LOWER_END_POINT:
                    return this.ExitLowerEndPoint((Production)node);
                case (int)Asn1Constants.UPPER_END_POINT:
                    return this.ExitUpperEndPoint((Production)node);
                case (int)Asn1Constants.SIZE_CONSTRAINT:
                    return this.ExitSizeConstraint((Production)node);
                case (int)Asn1Constants.ALPHABET_CONSTRAINT:
                    return this.ExitAlphabetConstraint((Production)node);
                case (int)Asn1Constants.CONTAINED_TYPE_CONSTRAINT:
                    return this.ExitContainedTypeConstraint((Production)node);
                case (int)Asn1Constants.INNER_TYPE_CONSTRAINT:
                    return this.ExitInnerTypeConstraint((Production)node);
                case (int)Asn1Constants.COMPONENTS_LIST:
                    return this.ExitComponentsList((Production)node);
                case (int)Asn1Constants.COMPONENTS_LIST_TAIL:
                    return this.ExitComponentsListTail((Production)node);
                case (int)Asn1Constants.COMPONENT_CONSTRAINT:
                    return this.ExitComponentConstraint((Production)node);
                case (int)Asn1Constants.COMPONENT_VALUE_PRESENCE:
                    return this.ExitComponentValuePresence((Production)node);
                case (int)Asn1Constants.COMPONENT_PRESENCE:
                    return this.ExitComponentPresence((Production)node);
                case (int)Asn1Constants.VALUE_ASSIGNMENT:
                    return this.ExitValueAssignment((Production)node);
                case (int)Asn1Constants.VALUE:
                    return this.ExitValue((Production)node);
                case (int)Asn1Constants.DEFINED_VALUE:
                    return this.ExitDefinedValue((Production)node);
                case (int)Asn1Constants.BUILTIN_VALUE:
                    return this.ExitBuiltinValue((Production)node);
                case (int)Asn1Constants.NULL_VALUE:
                    return this.ExitNullValue((Production)node);
                case (int)Asn1Constants.BOOLEAN_VALUE:
                    return this.ExitBooleanValue((Production)node);
                case (int)Asn1Constants.SPECIAL_REAL_VALUE:
                    return this.ExitSpecialRealValue((Production)node);
                case (int)Asn1Constants.NUMBER_VALUE:
                    return this.ExitNumberValue((Production)node);
                case (int)Asn1Constants.BINARY_VALUE:
                    return this.ExitBinaryValue((Production)node);
                case (int)Asn1Constants.HEXADECIMAL_VALUE:
                    return this.ExitHexadecimalValue((Production)node);
                case (int)Asn1Constants.STRING_VALUE:
                    return this.ExitStringValue((Production)node);
                case (int)Asn1Constants.BIT_OR_OBJECT_IDENTIFIER_VALUE:
                    return this.ExitBitOrObjectIdentifierValue((Production)node);
                case (int)Asn1Constants.BIT_VALUE:
                    return this.ExitBitValue((Production)node);
                case (int)Asn1Constants.OBJECT_IDENTIFIER_VALUE:
                    return this.ExitObjectIdentifierValue((Production)node);
                case (int)Asn1Constants.NAME_VALUE_LIST:
                    return this.ExitNameValueList((Production)node);
                case (int)Asn1Constants.NAME_VALUE_COMPONENT:
                    return this.ExitNameValueComponent((Production)node);
                case (int)Asn1Constants.NAME_OR_NUMBER:
                    return this.ExitNameOrNumber((Production)node);
                case (int)Asn1Constants.NAME_AND_NUMBER:
                    return this.ExitNameAndNumber((Production)node);
                case (int)Asn1Constants.DEFINED_MACRO_TYPE:
                    return this.ExitDefinedMacroType((Production)node);
                case (int)Asn1Constants.DEFINED_MACRO_NAME:
                    return this.ExitDefinedMacroName((Production)node);
                case (int)Asn1Constants.SNMP_MODULE_IDENTITY_MACRO_TYPE:
                    return this.ExitSnmpModuleIdentityMacroType((Production)node);
                case (int)Asn1Constants.SNMP_OBJECT_IDENTITY_MACRO_TYPE:
                    return this.ExitSnmpObjectIdentityMacroType((Production)node);
                case (int)Asn1Constants.SNMP_OBJECT_TYPE_MACRO_TYPE:
                    return this.ExitSnmpObjectTypeMacroType((Production)node);
                case (int)Asn1Constants.SNMP_NOTIFICATION_TYPE_MACRO_TYPE:
                    return this.ExitSnmpNotificationTypeMacroType((Production)node);
                case (int)Asn1Constants.SNMP_TRAP_TYPE_MACRO_TYPE:
                    return this.ExitSnmpTrapTypeMacroType((Production)node);
                case (int)Asn1Constants.SNMP_TEXTUAL_CONVENTION_MACRO_TYPE:
                    return this.ExitSnmpTextualConventionMacroType((Production)node);
                case (int)Asn1Constants.SNMP_OBJECT_GROUP_MACRO_TYPE:
                    return this.ExitSnmpObjectGroupMacroType((Production)node);
                case (int)Asn1Constants.SNMP_NOTIFICATION_GROUP_MACRO_TYPE:
                    return this.ExitSnmpNotificationGroupMacroType((Production)node);
                case (int)Asn1Constants.SNMP_MODULE_COMPLIANCE_MACRO_TYPE:
                    return this.ExitSnmpModuleComplianceMacroType((Production)node);
                case (int)Asn1Constants.SNMP_AGENT_CAPABILITIES_MACRO_TYPE:
                    return this.ExitSnmpAgentCapabilitiesMacroType((Production)node);
                case (int)Asn1Constants.SNMP_UPDATE_PART:
                    return this.ExitSnmpUpdatePart((Production)node);
                case (int)Asn1Constants.SNMP_ORGANIZATION_PART:
                    return this.ExitSnmpOrganizationPart((Production)node);
                case (int)Asn1Constants.SNMP_CONTACT_PART:
                    return this.ExitSnmpContactPart((Production)node);
                case (int)Asn1Constants.SNMP_DESCR_PART:
                    return this.ExitSnmpDescrPart((Production)node);
                case (int)Asn1Constants.SNMP_REVISION_PART:
                    return this.ExitSnmpRevisionPart((Production)node);
                case (int)Asn1Constants.SNMP_STATUS_PART:
                    return this.ExitSnmpStatusPart((Production)node);
                case (int)Asn1Constants.SNMP_REFER_PART:
                    return this.ExitSnmpReferPart((Production)node);
                case (int)Asn1Constants.SNMP_SYNTAX_PART:
                    return this.ExitSnmpSyntaxPart((Production)node);
                case (int)Asn1Constants.SNMP_UNITS_PART:
                    return this.ExitSnmpUnitsPart((Production)node);
                case (int)Asn1Constants.SNMP_ACCESS_PART:
                    return this.ExitSnmpAccessPart((Production)node);
                case (int)Asn1Constants.SNMP_INDEX_PART:
                    return this.ExitSnmpIndexPart((Production)node);
                case (int)Asn1Constants.INDEX_VALUE_LIST:
                    return this.ExitIndexValueList((Production)node);
                case (int)Asn1Constants.INDEX_VALUE:
                    return this.ExitIndexValue((Production)node);
                case (int)Asn1Constants.INDEX_TYPE:
                    return this.ExitIndexType((Production)node);
                case (int)Asn1Constants.SNMP_DEF_VAL_PART:
                    return this.ExitSnmpDefValPart((Production)node);
                case (int)Asn1Constants.SNMP_OBJECTS_PART:
                    return this.ExitSnmpObjectsPart((Production)node);
                case (int)Asn1Constants.VALUE_LIST:
                    return this.ExitValueList((Production)node);
                case (int)Asn1Constants.SNMP_ENTERPRISE_PART:
                    return this.ExitSnmpEnterprisePart((Production)node);
                case (int)Asn1Constants.SNMP_VAR_PART:
                    return this.ExitSnmpVarPart((Production)node);
                case (int)Asn1Constants.SNMP_DISPLAY_PART:
                    return this.ExitSnmpDisplayPart((Production)node);
                case (int)Asn1Constants.SNMP_NOTIFICATIONS_PART:
                    return this.ExitSnmpNotificationsPart((Production)node);
                case (int)Asn1Constants.SNMP_MODULE_PART:
                    return this.ExitSnmpModulePart((Production)node);
                case (int)Asn1Constants.SNMP_MODULE_IMPORT:
                    return this.ExitSnmpModuleImport((Production)node);
                case (int)Asn1Constants.SNMP_MANDATORY_PART:
                    return this.ExitSnmpMandatoryPart((Production)node);
                case (int)Asn1Constants.SNMP_COMPLIANCE_PART:
                    return this.ExitSnmpCompliancePart((Production)node);
                case (int)Asn1Constants.COMPLIANCE_GROUP:
                    return this.ExitComplianceGroup((Production)node);
                case (int)Asn1Constants.COMPLIANCE_OBJECT:
                    return this.ExitComplianceObject((Production)node);
                case (int)Asn1Constants.SNMP_WRITE_SYNTAX_PART:
                    return this.ExitSnmpWriteSyntaxPart((Production)node);
                case (int)Asn1Constants.SNMP_PRODUCT_RELEASE_PART:
                    return this.ExitSnmpProductReleasePart((Production)node);
                case (int)Asn1Constants.SNMP_MODULE_SUPPORT_PART:
                    return this.ExitSnmpModuleSupportPart((Production)node);
                case (int)Asn1Constants.SNMP_VARIATION_PART:
                    return this.ExitSnmpVariationPart((Production)node);
                case (int)Asn1Constants.SNMP_CREATION_PART:
                    return this.ExitSnmpCreationPart((Production)node);
            }

            return node;
        }

        /// <summary>Called when adding a child to a parse tree
        /// node.</summary>
        /// <param name='node'>the parent node</param>
        /// <param name='child'>the child node, or null</param>
        /// <exception cref='ParseException'>if the node analysis
        /// discovered errors</exception>
        public override void Child(Production node, Node child)
        {
            switch (node.Id)
            {
                case (int)Asn1Constants.START:
                    this.ChildStart(node, child);
                    break;
                case (int)Asn1Constants.MODULE_DEFINITION:
                    this.ChildModuleDefinition(node, child);
                    break;
                case (int)Asn1Constants.MODULE_IDENTIFIER:
                    this.ChildModuleIdentifier(node, child);
                    break;
                case (int)Asn1Constants.MODULE_REFERENCE:
                    this.ChildModuleReference(node, child);
                    break;
                case (int)Asn1Constants.TAG_DEFAULT:
                    this.ChildTagDefault(node, child);
                    break;
                case (int)Asn1Constants.MODULE_BODY:
                    this.ChildModuleBody(node, child);
                    break;
                case (int)Asn1Constants.EXPORT_LIST:
                    this.ChildExportList(node, child);
                    break;
                case (int)Asn1Constants.IMPORT_LIST:
                    this.ChildImportList(node, child);
                    break;
                case (int)Asn1Constants.SYMBOLS_FROM_MODULE:
                    this.ChildSymbolsFromModule(node, child);
                    break;
                case (int)Asn1Constants.SYMBOL_LIST:
                    this.ChildSymbolList(node, child);
                    break;
                case (int)Asn1Constants.SYMBOL:
                    this.ChildSymbol(node, child);
                    break;
                case (int)Asn1Constants.ASSIGNMENT_LIST:
                    this.ChildAssignmentList(node, child);
                    break;
                case (int)Asn1Constants.ASSIGNMENT:
                    this.ChildAssignment(node, child);
                    break;
                case (int)Asn1Constants.MACRO_DEFINITION:
                    this.ChildMacroDefinition(node, child);
                    break;
                case (int)Asn1Constants.MACRO_REFERENCE:
                    this.ChildMacroReference(node, child);
                    break;
                case (int)Asn1Constants.MACRO_BODY:
                    this.ChildMacroBody(node, child);
                    break;
                case (int)Asn1Constants.MACRO_BODY_ELEMENT:
                    this.ChildMacroBodyElement(node, child);
                    break;
                case (int)Asn1Constants.TYPE_ASSIGNMENT:
                    this.ChildTypeAssignment(node, child);
                    break;
                case (int)Asn1Constants.TYPE:
                    this.ChildType(node, child);
                    break;
                case (int)Asn1Constants.DEFINED_TYPE:
                    this.ChildDefinedType(node, child);
                    break;
                case (int)Asn1Constants.BUILTIN_TYPE:
                    this.ChildBuiltinType(node, child);
                    break;
                case (int)Asn1Constants.NULL_TYPE:
                    this.ChildNullType(node, child);
                    break;
                case (int)Asn1Constants.BOOLEAN_TYPE:
                    this.ChildBooleanType(node, child);
                    break;
                case (int)Asn1Constants.REAL_TYPE:
                    this.ChildRealType(node, child);
                    break;
                case (int)Asn1Constants.INTEGER_TYPE:
                    this.ChildIntegerType(node, child);
                    break;
                case (int)Asn1Constants.OBJECT_IDENTIFIER_TYPE:
                    this.ChildObjectIdentifierType(node, child);
                    break;
                case (int)Asn1Constants.STRING_TYPE:
                    this.ChildStringType(node, child);
                    break;
                case (int)Asn1Constants.BIT_STRING_TYPE:
                    this.ChildBitStringType(node, child);
                    break;
                case (int)Asn1Constants.BITS_TYPE:
                    this.ChildBitsType(node, child);
                    break;
                case (int)Asn1Constants.SEQUENCE_TYPE:
                    this.ChildSequenceType(node, child);
                    break;
                case (int)Asn1Constants.SEQUENCE_OF_TYPE:
                    this.ChildSequenceOfType(node, child);
                    break;
                case (int)Asn1Constants.SET_TYPE:
                    this.ChildSetType(node, child);
                    break;
                case (int)Asn1Constants.SET_OF_TYPE:
                    this.ChildSetOfType(node, child);
                    break;
                case (int)Asn1Constants.CHOICE_TYPE:
                    this.ChildChoiceType(node, child);
                    break;
                case (int)Asn1Constants.ENUMERATED_TYPE:
                    this.ChildEnumeratedType(node, child);
                    break;
                case (int)Asn1Constants.SELECTION_TYPE:
                    this.ChildSelectionType(node, child);
                    break;
                case (int)Asn1Constants.TAGGED_TYPE:
                    this.ChildTaggedType(node, child);
                    break;
                case (int)Asn1Constants.TAG:
                    this.ChildTag(node, child);
                    break;
                case (int)Asn1Constants.CLASS:
                    this.ChildClass(node, child);
                    break;
                case (int)Asn1Constants.EXPLICIT_OR_IMPLICIT_TAG:
                    this.ChildExplicitOrImplicitTag(node, child);
                    break;
                case (int)Asn1Constants.ANY_TYPE:
                    this.ChildAnyType(node, child);
                    break;
                case (int)Asn1Constants.ELEMENT_TYPE_LIST:
                    this.ChildElementTypeList(node, child);
                    break;
                case (int)Asn1Constants.ELEMENT_TYPE:
                    this.ChildElementType(node, child);
                    break;
                case (int)Asn1Constants.OPTIONAL_OR_DEFAULT_ELEMENT:
                    this.ChildOptionalOrDefaultElement(node, child);
                    break;
                case (int)Asn1Constants.VALUE_OR_CONSTRAINT_LIST:
                    this.ChildValueOrConstraintList(node, child);
                    break;
                case (int)Asn1Constants.NAMED_NUMBER_LIST:
                    this.ChildNamedNumberList(node, child);
                    break;
                case (int)Asn1Constants.NAMED_NUMBER:
                    this.ChildNamedNumber(node, child);
                    break;
                case (int)Asn1Constants.NUMBER:
                    this.ChildNumber(node, child);
                    break;
                case (int)Asn1Constants.CONSTRAINT_LIST:
                    this.ChildConstraintList(node, child);
                    break;
                case (int)Asn1Constants.CONSTRAINT:
                    this.ChildConstraint(node, child);
                    break;
                case (int)Asn1Constants.VALUE_CONSTRAINT_LIST:
                    this.ChildValueConstraintList(node, child);
                    break;
                case (int)Asn1Constants.VALUE_CONSTRAINT:
                    this.ChildValueConstraint(node, child);
                    break;
                case (int)Asn1Constants.VALUE_RANGE:
                    this.ChildValueRange(node, child);
                    break;
                case (int)Asn1Constants.LOWER_END_POINT:
                    this.ChildLowerEndPoint(node, child);
                    break;
                case (int)Asn1Constants.UPPER_END_POINT:
                    this.ChildUpperEndPoint(node, child);
                    break;
                case (int)Asn1Constants.SIZE_CONSTRAINT:
                    this.ChildSizeConstraint(node, child);
                    break;
                case (int)Asn1Constants.ALPHABET_CONSTRAINT:
                    this.ChildAlphabetConstraint(node, child);
                    break;
                case (int)Asn1Constants.CONTAINED_TYPE_CONSTRAINT:
                    this.ChildContainedTypeConstraint(node, child);
                    break;
                case (int)Asn1Constants.INNER_TYPE_CONSTRAINT:
                    this.ChildInnerTypeConstraint(node, child);
                    break;
                case (int)Asn1Constants.COMPONENTS_LIST:
                    this.ChildComponentsList(node, child);
                    break;
                case (int)Asn1Constants.COMPONENTS_LIST_TAIL:
                    this.ChildComponentsListTail(node, child);
                    break;
                case (int)Asn1Constants.COMPONENT_CONSTRAINT:
                    this.ChildComponentConstraint(node, child);
                    break;
                case (int)Asn1Constants.COMPONENT_VALUE_PRESENCE:
                    this.ChildComponentValuePresence(node, child);
                    break;
                case (int)Asn1Constants.COMPONENT_PRESENCE:
                    this.ChildComponentPresence(node, child);
                    break;
                case (int)Asn1Constants.VALUE_ASSIGNMENT:
                    this.ChildValueAssignment(node, child);
                    break;
                case (int)Asn1Constants.VALUE:
                    this.ChildValue(node, child);
                    break;
                case (int)Asn1Constants.DEFINED_VALUE:
                    this.ChildDefinedValue(node, child);
                    break;
                case (int)Asn1Constants.BUILTIN_VALUE:
                    this.ChildBuiltinValue(node, child);
                    break;
                case (int)Asn1Constants.NULL_VALUE:
                    this.ChildNullValue(node, child);
                    break;
                case (int)Asn1Constants.BOOLEAN_VALUE:
                    this.ChildBooleanValue(node, child);
                    break;
                case (int)Asn1Constants.SPECIAL_REAL_VALUE:
                    this.ChildSpecialRealValue(node, child);
                    break;
                case (int)Asn1Constants.NUMBER_VALUE:
                    this.ChildNumberValue(node, child);
                    break;
                case (int)Asn1Constants.BINARY_VALUE:
                    this.ChildBinaryValue(node, child);
                    break;
                case (int)Asn1Constants.HEXADECIMAL_VALUE:
                    this.ChildHexadecimalValue(node, child);
                    break;
                case (int)Asn1Constants.STRING_VALUE:
                    this.ChildStringValue(node, child);
                    break;
                case (int)Asn1Constants.BIT_OR_OBJECT_IDENTIFIER_VALUE:
                    this.ChildBitOrObjectIdentifierValue(node, child);
                    break;
                case (int)Asn1Constants.BIT_VALUE:
                    this.ChildBitValue(node, child);
                    break;
                case (int)Asn1Constants.OBJECT_IDENTIFIER_VALUE:
                    this.ChildObjectIdentifierValue(node, child);
                    break;
                case (int)Asn1Constants.NAME_VALUE_LIST:
                    this.ChildNameValueList(node, child);
                    break;
                case (int)Asn1Constants.NAME_VALUE_COMPONENT:
                    this.ChildNameValueComponent(node, child);
                    break;
                case (int)Asn1Constants.NAME_OR_NUMBER:
                    this.ChildNameOrNumber(node, child);
                    break;
                case (int)Asn1Constants.NAME_AND_NUMBER:
                    this.ChildNameAndNumber(node, child);
                    break;
                case (int)Asn1Constants.DEFINED_MACRO_TYPE:
                    this.ChildDefinedMacroType(node, child);
                    break;
                case (int)Asn1Constants.DEFINED_MACRO_NAME:
                    this.ChildDefinedMacroName(node, child);
                    break;
                case (int)Asn1Constants.SNMP_MODULE_IDENTITY_MACRO_TYPE:
                    this.ChildSnmpModuleIdentityMacroType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_OBJECT_IDENTITY_MACRO_TYPE:
                    this.ChildSnmpObjectIdentityMacroType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_OBJECT_TYPE_MACRO_TYPE:
                    this.ChildSnmpObjectTypeMacroType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_NOTIFICATION_TYPE_MACRO_TYPE:
                    this.ChildSnmpNotificationTypeMacroType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_TRAP_TYPE_MACRO_TYPE:
                    this.ChildSnmpTrapTypeMacroType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_TEXTUAL_CONVENTION_MACRO_TYPE:
                    this.ChildSnmpTextualConventionMacroType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_OBJECT_GROUP_MACRO_TYPE:
                    this.ChildSnmpObjectGroupMacroType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_NOTIFICATION_GROUP_MACRO_TYPE:
                    this.ChildSnmpNotificationGroupMacroType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_MODULE_COMPLIANCE_MACRO_TYPE:
                    this.ChildSnmpModuleComplianceMacroType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_AGENT_CAPABILITIES_MACRO_TYPE:
                    this.ChildSnmpAgentCapabilitiesMacroType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_UPDATE_PART:
                    this.ChildSnmpUpdatePart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_ORGANIZATION_PART:
                    this.ChildSnmpOrganizationPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_CONTACT_PART:
                    this.ChildSnmpContactPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_DESCR_PART:
                    this.ChildSnmpDescrPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_REVISION_PART:
                    this.ChildSnmpRevisionPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_STATUS_PART:
                    this.ChildSnmpStatusPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_REFER_PART:
                    this.ChildSnmpReferPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_SYNTAX_PART:
                    this.ChildSnmpSyntaxPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_UNITS_PART:
                    this.ChildSnmpUnitsPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_ACCESS_PART:
                    this.ChildSnmpAccessPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_INDEX_PART:
                    this.ChildSnmpIndexPart(node, child);
                    break;
                case (int)Asn1Constants.INDEX_VALUE_LIST:
                    this.ChildIndexValueList(node, child);
                    break;
                case (int)Asn1Constants.INDEX_VALUE:
                    this.ChildIndexValue(node, child);
                    break;
                case (int)Asn1Constants.INDEX_TYPE:
                    this.ChildIndexType(node, child);
                    break;
                case (int)Asn1Constants.SNMP_DEF_VAL_PART:
                    this.ChildSnmpDefValPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_OBJECTS_PART:
                    this.ChildSnmpObjectsPart(node, child);
                    break;
                case (int)Asn1Constants.VALUE_LIST:
                    this.ChildValueList(node, child);
                    break;
                case (int)Asn1Constants.SNMP_ENTERPRISE_PART:
                    this.ChildSnmpEnterprisePart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_VAR_PART:
                    this.ChildSnmpVarPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_DISPLAY_PART:
                    this.ChildSnmpDisplayPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_NOTIFICATIONS_PART:
                    this.ChildSnmpNotificationsPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_MODULE_PART:
                    this.ChildSnmpModulePart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_MODULE_IMPORT:
                    this.ChildSnmpModuleImport(node, child);
                    break;
                case (int)Asn1Constants.SNMP_MANDATORY_PART:
                    this.ChildSnmpMandatoryPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_COMPLIANCE_PART:
                    this.ChildSnmpCompliancePart(node, child);
                    break;
                case (int)Asn1Constants.COMPLIANCE_GROUP:
                    this.ChildComplianceGroup(node, child);
                    break;
                case (int)Asn1Constants.COMPLIANCE_OBJECT:
                    this.ChildComplianceObject(node, child);
                    break;
                case (int)Asn1Constants.SNMP_WRITE_SYNTAX_PART:
                    this.ChildSnmpWriteSyntaxPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_PRODUCT_RELEASE_PART:
                    this.ChildSnmpProductReleasePart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_MODULE_SUPPORT_PART:
                    this.ChildSnmpModuleSupportPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_VARIATION_PART:
                    this.ChildSnmpVariationPart(node, child);
                    break;
                case (int)Asn1Constants.SNMP_CREATION_PART:
                    this.ChildSnmpCreationPart(node, child);
                    break;
            }
        }

        /// <summary>Called when entering a parse tree node.</summary>
        /// <param name='node'>the node being entered</param>
        /// <exception cref='ParseException'>
        /// If the node analysis discovered errors
        /// </exception>
        public virtual void EnterDot(Token node)
        {
        }

         /// <summary>Called when exiting a parse tree node.</summary>
         /// <param name='node'>the node being exited</param>
         /// <returns>
         /// The node to add to the parse tree, or null if no
         /// parse tree should be created
         /// </returns>
         /// <exception cref='ParseException'>
         /// If the node analysis discovered errors
         /// </exception>
        public virtual Node ExitDot(Token node)
        {
            return node;
        }

         /// <summary>Called when entering a parse tree node.</summary>
         /// <param name='node'>the node being entered</param>
         /// <exception cref='ParseException'>
         /// If the node analysis discovered errors
         /// </exception>
        public virtual void EnterDoubleDot(Token node)
        {
        }

         /// <summary>Called when exiting a parse tree node.</summary>
         /// <param name='node'>the node being exited</param>
         /// <returns>
         /// The node to add to the parse tree, or null if no
         /// parse tree should be created
         /// </returns>
         /// <exception cref='ParseException'>
         /// If the node analysis discovered errors
         /// </exception>
        public virtual Node ExitDoubleDot(Token node)
        {
            return node;
        }

        /// <summary>Called when entering a parse tree node.</summary>
        /// <param name='node'>the node being entered</param>
        /// <exception cref='ParseException'>
        /// If the node analysis discovered errors
        /// </exception>
        public virtual void EnterTripleDot(Token node)
        {
        }

        /// <summary>Called when exiting a parse tree node.</summary>
        /// <param name='node'>the node being exited</param>
        /// <returns>
        /// The node to add to the parse tree, or null if no
        /// parse tree should be created
        /// </returns>
        /// <exception cref='ParseException'>
        /// If the node analysis discovered errors
        /// </exception>
        public virtual Node ExitTripleDot(Token node)
        {
            return node;
        }

        /// <summary>Called when entering a parse tree node.</summary>
        /// <param name='node'>the node being entered</param>
        /// <exception cref='ParseException'>if the node analysis
        /// discovered errors</exception>
        public virtual void EnterComma(Token node)
        {
        }

        /// <summary>Called when exiting a parse tree node.</summary>
        ///
        /// <param name='node'>the node being exited</param>
        /// <returns>the node to add to the parse tree, or
        ///          null if no parse tree should be created</returns>
        /// <exception cref='ParseException'>if the node analysis
        /// discovered errors</exception>
        public virtual Node ExitComma(Token node)
        {
            return node;
        }

        /// <summary>Called when entering a parse tree node.</summary>
        /// <param name='node'>the node being entered</param>
        /// <exception cref='ParseException'>if the node analysis
        /// discovered errors</exception>
        public virtual void EnterSemiColon(Token node)
        {
        }

        /// <summary>Called when exiting a parse tree node.</summary>
        /// <param name='node'>the node being exited</param>
        /// <returns>
        /// The node to add to the parse tree, or null if no
        /// parse tree should be created
        /// </returns>
        /// <exception cref='ParseException'>
        /// If the node analysis discovered errors</exception>
        public virtual Node ExitSemiColon(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterLeftParen(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitLeftParen(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterRightParen(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitRightParen(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterLeftBrace(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitLeftBrace(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterRightBrace(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitRightBrace(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterLeftBracket(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitLeftBracket(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterRightBracket(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitRightBracket(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMinus(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMinus(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterLessThan(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitLessThan(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterVerticalBar(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitVerticalBar(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDefinition(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDefinition(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDefinitions(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDefinitions(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterExplicit(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitExplicit(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterImplicit(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitImplicit(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterTags(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitTags(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBegin(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBegin(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterEnd(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitEnd(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterExports(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitExports(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterImports(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitImports(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterFrom(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitFrom(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMacro(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMacro(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterInteger(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitInteger(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterReal(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitReal(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBoolean(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBoolean(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNull(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNull(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBit(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBit(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterOctet(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitOctet(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterString(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitString(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterEnumerated(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitEnumerated(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSequence(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSequence(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSet(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSet(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterOf(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitOf(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterChoice(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitChoice(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterUniversal(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitUniversal(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterApplication(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitApplication(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterPrivate(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitPrivate(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterAny(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitAny(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDefined(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDefined(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBy(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBy(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterObject(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitObject(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterIdentifier(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitIdentifier(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterIncludes(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitIncludes(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMin(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMin(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMax(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMax(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSize(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSize(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterWith(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitWith(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterComponent(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitComponent(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterComponents(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitComponents(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterPresent(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitPresent(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterAbsent(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitAbsent(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterOptional(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitOptional(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDefault(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDefault(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterTrue(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitTrue(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterFalse(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitFalse(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterPlusInfinity(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitPlusInfinity(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMinusInfinity(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMinusInfinity(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterModuleIdentity(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitModuleIdentity(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterObjectIdentity(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitObjectIdentity(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterObjectType(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitObjectType(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNotificationType(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNotificationType(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterTrapType(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitTrapType(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterTextualConvention(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitTextualConvention(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterObjectGroup(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitObjectGroup(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNotificationGroup(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNotificationGroup(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterModuleCompliance(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitModuleCompliance(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterAgentCapabilities(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitAgentCapabilities(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterLastUpdated(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitLastUpdated(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterOrganization(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitOrganization(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterContactInfo(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitContactInfo(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDescription(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDescription(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterRevision(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitRevision(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterStatus(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitStatus(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterReference(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitReference(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSyntax(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSyntax(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBits(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBits(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterUnits(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitUnits(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterAccess(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitAccess(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMaxAccess(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMaxAccess(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMinAccess(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMinAccess(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterIndex(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitIndex(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterAugments(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitAugments(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterImplied(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitImplied(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDefval(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDefval(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterObjects(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitObjects(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterEnterprise(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitEnterprise(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterVariables(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitVariables(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDisplayHint(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDisplayHint(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNotifications(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNotifications(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterModule(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitModule(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMandatoryGroups(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMandatoryGroups(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterGroup(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitGroup(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterWriteSyntax(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitWriteSyntax(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterProductRelease(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitProductRelease(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSupports(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSupports(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterVariation(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitVariation(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterCreationRequires(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitCreationRequires(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBinaryString(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBinaryString(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterHexadecimalString(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitHexadecimalString(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterQuotedString(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitQuotedString(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterIdentifierString(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitIdentifierString(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNumberString(Token node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNumberString(Token node)
        {
            return node;
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterStart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitStart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildStart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterModuleDefinition(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitModuleDefinition(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildModuleDefinition(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterModuleIdentifier(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitModuleIdentifier(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildModuleIdentifier(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterModuleReference(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitModuleReference(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildModuleReference(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterTagDefault(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitTagDefault(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildTagDefault(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterModuleBody(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitModuleBody(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildModuleBody(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterExportList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitExportList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildExportList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterImportList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitImportList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildImportList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSymbolsFromModule(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSymbolsFromModule(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSymbolsFromModule(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSymbolList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSymbolList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSymbolList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSymbol(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSymbol(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSymbol(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterAssignmentList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitAssignmentList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildAssignmentList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterAssignment(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitAssignment(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildAssignment(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMacroDefinition(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMacroDefinition(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildMacroDefinition(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMacroReference(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMacroReference(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildMacroReference(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMacroBody(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMacroBody(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildMacroBody(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterMacroBodyElement(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitMacroBodyElement(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildMacroBodyElement(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterTypeAssignment(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitTypeAssignment(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildTypeAssignment(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDefinedType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDefinedType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildDefinedType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBuiltinType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBuiltinType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildBuiltinType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNullType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNullType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildNullType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBooleanType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBooleanType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildBooleanType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterRealType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitRealType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildRealType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterIntegerType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitIntegerType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildIntegerType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterObjectIdentifierType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitObjectIdentifierType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildObjectIdentifierType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterStringType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitStringType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildStringType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBitStringType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBitStringType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildBitStringType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBitsType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBitsType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildBitsType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSequenceType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSequenceType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSequenceType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSequenceOfType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSequenceOfType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSequenceOfType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSetType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSetType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSetType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSetOfType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSetOfType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSetOfType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterChoiceType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitChoiceType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildChoiceType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterEnumeratedType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitEnumeratedType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildEnumeratedType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSelectionType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSelectionType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSelectionType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterTaggedType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitTaggedType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildTaggedType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterTag(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitTag(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildTag(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterClass(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitClass(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildClass(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterExplicitOrImplicitTag(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitExplicitOrImplicitTag(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildExplicitOrImplicitTag(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterAnyType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitAnyType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildAnyType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterElementTypeList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitElementTypeList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildElementTypeList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterElementType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitElementType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildElementType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterOptionalOrDefaultElement(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitOptionalOrDefaultElement(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildOptionalOrDefaultElement(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterValueOrConstraintList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitValueOrConstraintList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildValueOrConstraintList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNamedNumberList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNamedNumberList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildNamedNumberList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNamedNumber(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNamedNumber(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildNamedNumber(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNumber(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNumber(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildNumber(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterConstraintList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitConstraintList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildConstraintList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterConstraint(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitConstraint(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildConstraint(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterValueConstraintList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitValueConstraintList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildValueConstraintList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterValueConstraint(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitValueConstraint(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildValueConstraint(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterValueRange(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitValueRange(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildValueRange(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterLowerEndPoint(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitLowerEndPoint(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildLowerEndPoint(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterUpperEndPoint(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitUpperEndPoint(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildUpperEndPoint(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSizeConstraint(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSizeConstraint(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSizeConstraint(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterAlphabetConstraint(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitAlphabetConstraint(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildAlphabetConstraint(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterContainedTypeConstraint(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitContainedTypeConstraint(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildContainedTypeConstraint(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterInnerTypeConstraint(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitInnerTypeConstraint(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildInnerTypeConstraint(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterComponentsList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitComponentsList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildComponentsList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterComponentsListTail(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitComponentsListTail(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildComponentsListTail(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterComponentConstraint(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitComponentConstraint(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildComponentConstraint(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterComponentValuePresence(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitComponentValuePresence(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildComponentValuePresence(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterComponentPresence(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitComponentPresence(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildComponentPresence(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterValueAssignment(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitValueAssignment(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildValueAssignment(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDefinedValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDefinedValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildDefinedValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBuiltinValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBuiltinValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildBuiltinValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNullValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNullValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildNullValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBooleanValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBooleanValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildBooleanValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSpecialRealValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSpecialRealValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSpecialRealValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNumberValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNumberValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildNumberValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBinaryValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBinaryValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildBinaryValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterHexadecimalValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitHexadecimalValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildHexadecimalValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterStringValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitStringValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildStringValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBitOrObjectIdentifierValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBitOrObjectIdentifierValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildBitOrObjectIdentifierValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterBitValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitBitValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildBitValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterObjectIdentifierValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitObjectIdentifierValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildObjectIdentifierValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNameValueList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNameValueList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildNameValueList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNameValueComponent(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNameValueComponent(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildNameValueComponent(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNameOrNumber(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNameOrNumber(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildNameOrNumber(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterNameAndNumber(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitNameAndNumber(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildNameAndNumber(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDefinedMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDefinedMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildDefinedMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterDefinedMacroName(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitDefinedMacroName(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildDefinedMacroName(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpModuleIdentityMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpModuleIdentityMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpModuleIdentityMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpObjectIdentityMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpObjectIdentityMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpObjectIdentityMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpObjectTypeMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpObjectTypeMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpObjectTypeMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpNotificationTypeMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpNotificationTypeMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpNotificationTypeMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpTrapTypeMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpTrapTypeMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpTrapTypeMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpTextualConventionMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpTextualConventionMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpTextualConventionMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpObjectGroupMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpObjectGroupMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpObjectGroupMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpNotificationGroupMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpNotificationGroupMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpNotificationGroupMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpModuleComplianceMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpModuleComplianceMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpModuleComplianceMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpAgentCapabilitiesMacroType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpAgentCapabilitiesMacroType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpAgentCapabilitiesMacroType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpUpdatePart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpUpdatePart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpUpdatePart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpOrganizationPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpOrganizationPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpOrganizationPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpContactPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpContactPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpContactPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpDescrPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpDescrPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpDescrPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpRevisionPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpRevisionPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpRevisionPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpStatusPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpStatusPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpStatusPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpReferPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpReferPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpReferPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpSyntaxPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpSyntaxPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpSyntaxPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpUnitsPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpUnitsPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpUnitsPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpAccessPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpAccessPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpAccessPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpIndexPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpIndexPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpIndexPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterIndexValueList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitIndexValueList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildIndexValueList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterIndexValue(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitIndexValue(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildIndexValue(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterIndexType(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitIndexType(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildIndexType(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpDefValPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpDefValPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpDefValPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpObjectsPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpObjectsPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpObjectsPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterValueList(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitValueList(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildValueList(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpEnterprisePart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpEnterprisePart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpEnterprisePart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpVarPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpVarPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpVarPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpDisplayPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpDisplayPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpDisplayPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpNotificationsPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpNotificationsPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpNotificationsPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpModulePart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpModulePart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpModulePart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpModuleImport(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpModuleImport(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpModuleImport(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpMandatoryPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpMandatoryPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpMandatoryPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpCompliancePart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpCompliancePart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpCompliancePart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterComplianceGroup(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitComplianceGroup(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildComplianceGroup(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterComplianceObject(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitComplianceObject(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildComplianceObject(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpWriteSyntaxPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpWriteSyntaxPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpWriteSyntaxPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpProductReleasePart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpProductReleasePart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpProductReleasePart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpModuleSupportPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpModuleSupportPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpModuleSupportPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpVariationPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpVariationPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpVariationPart(Production node, Node child)
        {
            node.AddChild(child);
        }

        /**
         * <summary>Called when entering a parse tree node.</summary>
         *
         * <param name='node'>the node being entered</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void EnterSnmpCreationPart(Production node)
        {
        }

        /**
         * <summary>Called when exiting a parse tree node.</summary>
         *
         * <param name='node'>the node being exited</param>
         *
         * <returns>the node to add to the parse tree, or
         *          null if no parse tree should be created</returns>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual Node ExitSnmpCreationPart(Production node)
        {
            return node;
        }

        /**
         * <summary>Called when adding a child to a parse tree
         * node.</summary>
         *
         * <param name='node'>the parent node</param>
         * <param name='child'>the child node, or null</param>
         *
         * <exception cref='ParseException'>if the node analysis
         * discovered errors</exception>
         */
        public virtual void ChildSnmpCreationPart(Production node, Node child)
        {
            node.AddChild(child);
        }
    }
}
